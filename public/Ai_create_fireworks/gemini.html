<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>클릭 폭죽 시뮬레이터</title>
    <!-- Tailwind CSS 로딩 (옵션: 기본 스타일링에 사용) -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* HTML 및 Body를 전체 화면으로 설정 */
        html, body {
            margin: 0;
            padding: 0;
            overflow: hidden; /* 스크롤 방지 */
            height: 100%;
            width: 100%;
            background-color: #000; /* 폭죽이 돋보이도록 어두운 배경 */
            font-family: 'Inter', sans-serif;
            cursor: crosshair; /* 십자 모양 커서로 변경 */
        }
        /* 캔버스 스타일 */
        #fireworksCanvas {
            height: 100%;
        width: 100%;
            display: block;
        }
        /* 안내 메시지 스타일 */
        #message {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #ffffff99;
            font-size: 1.5rem;
            pointer-events: none; /* 클릭 이벤트가 캔버스에 전달되도록 설정 */
            padding: 1rem 2rem;
            border-radius: 0.5rem;
            background-color: rgba(0, 0, 0, 0.5);
            opacity: 1;
            transition: opacity 1s;
        }
        .hidden {
            opacity: 0 !important;
        }
    </style>
</head>
<body class="bg-gray-900">
    <!-- 캔버스: 폭죽 효과가 그려질 영역 -->
    <canvas id="fireworksCanvas"></canvas>

    <!-- 사용자 안내 메시지 -->
    <div id="message">화면 아무 곳이나 클릭하여 폭죽을 터뜨려보세요!</div>

    <script type="module">
        // ------------------------------------
        // Firebase 관련 변수 (이 앱에서는 사용하지 않지만, 환경 변수 정의를 위해 유지)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        // ------------------------------------

        /** @type {HTMLCanvasElement} */
        let canvas;
        /** @type {CanvasRenderingContext2D} */
        let ctx;
        let rockets = []; // 발사 중인 로켓 객체 배열
        let particles = []; // 폭발 후 생성된 입자 객체 배열

        // 물리 상수
        const GRAVITY = 0.015; // 중력 가속도
        const DAMPING = 0.98; // 공기 저항 (속도 감쇠)

        // 캔버스 크기를 창 크기에 맞게 설정하고 메시지를 숨기는 함수
        function resizeCanvas() {
            canvas.width = canvas.clientWidth;
            canvas.height = canvas.clientHeight;
            // 배경을 검정색으로 다시 채우기
            ctx.fillStyle = '#000000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // 헬퍼: 무작위 색상 생성
        function getRandomColor() {
            const hue = Math.floor(Math.random() * 360);
            // HSL 색상 모델 사용: Hue는 랜덤, Saturation과 Lightness는 높게 유지하여 밝고 선명하게
            return `hsl(${hue}, 100%, 70%)`;
        }

        // ------------------------------------
        // 폭죽 입자 (Particle) 클래스
        // ------------------------------------
        class Particle {
            /**
             * @param {number} x - 초기 x 위치
             * @param {number} y - 초기 y 위치
             * @param {string} color - 입자 색상
             */
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                this.alpha = 1; // 투명도
                this.friction = 0.99; // 입자 자체의 감쇠
                this.decay = Math.random() * 0.03 + 0.01; // 입자 소멸 속도

                // 무작위 초기 속도 (폭발 효과)
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 5 + 1; // 1 ~ 6
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.size = Math.random() * 2 + 1;
            }

            // 입자 상태 업데이트
            update() {
                // 속도에 중력 적용
                this.vy += GRAVITY * 2;
                // 속도에 마찰 적용
                this.vx *= this.friction;
                this.vy *= this.friction;

                // 위치 업데이트
                this.x += this.vx;
                this.y += this.vy;

                // 투명도 감소 (페이드 아웃)
                this.alpha -= this.decay;

                // alpha가 0보다 크면 true (계속 활성), 아니면 false (소멸)
                return this.alpha > this.decay;
            }

            // 입자 그리기
            draw() {
                ctx.save();
                ctx.globalAlpha = this.alpha;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.restore();
            }
        }


        // ------------------------------------
        // 폭죽 로켓 (Rocket) 클래스
        // ------------------------------------
        class Rocket {
            /**
             * @param {number} targetX - 목표 x 위치 (클릭 지점)
             * @param {number} targetY - 목표 y 위치 (클릭 지점)
             * @param {number} startX - 초기 x 위치 (캔버스 중앙 하단)
             * @param {number} startY - 초기 y 위치 (캔버스 하단)
             */
            constructor(targetX, targetY, startX, startY) {
                this.x = startX;
                this.y = startY;
                this.targetX = targetX;
                this.targetY = targetY;

                // 색상 결정
                this.color = getRandomColor();

                // 목표를 향한 속도 계산
                const dx = targetX - startX;
                const dy = targetY - startY;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const initialSpeed = 15; // 초기 발사 속도

                this.vx = (dx / distance) * initialSpeed * 0.5; // x축 속도는 목표까지 도달하도록
                this.vy = (dy / distance) * initialSpeed; // y축 속도는 목표까지 도달하도록

                // 로켓이 터졌는지 여부
                this.exploded = false;
                // 로켓 꼬리 효과를 위한 과거 위치 저장
                this.history = [{ x: startX, y: startY }];
            }

            // 폭발 처리: 입자 생성
            explode() {
                this.exploded = true;
                const particleCount = 100 + Math.floor(Math.random() * 50); // 100~150개 입자

                for (let i = 0; i < particleCount; i++) {
                    particles.push(new Particle(this.x, this.y, this.color));
                }
            }

            // 로켓 상태 업데이트
            update() {
                if (this.exploded) return false; // 이미 폭발했다면 소멸

                // 꼬리 흔적을 위해 현재 위치를 기록 (최대 5개)
                this.history.push({ x: this.x, y: this.y });
                if (this.history.length > 5) {
                    this.history.shift();
                }

                // 로켓의 수직 이동을 중력 및 감쇠로 시뮬레이션
                this.vy += GRAVITY; // 로켓 속도에 중력 적용
                this.vx *= DAMPING;
                this.vy *= DAMPING;

                // 위치 업데이트
                this.x += this.vx;
                this.y += this.vy;

                // 터짐 조건 확인: 로켓이 목표 높이를 "지나쳤는지" 또는 "거의 도달했는지"
                // 로켓은 위로 올라가므로, 현재 y가 목표 y보다 작거나 같아지면 (y좌표는 위로 갈수록 작아짐) 터짐
                if (this.y <= this.targetY) {
                    this.explode();
                    return false; // 폭발 후 소멸
                }

                // y 속도가 0이 되면 (최고점 도달) 터짐 (추가 안전장치)
                if (this.vy > 0 && this.y < canvas.height * 0.9) { // vy가 양수(아래로 이동 시작)일 때
                   // this.explode();
                   // return false; // 폭발 후 소멸
                }


                return true; // 계속 활성
            }

            // 로켓 그리기
            draw() {
                if (this.exploded) return;

                ctx.save();
                // 꼬리 (History) 그리기
                ctx.beginPath();
                ctx.moveTo(this.history[0].x, this.history[0].y);
                for (let i = 1; i < this.history.length; i++) {
                    // 꼬리가 점점 옅어지도록 투명도 설정
                    ctx.globalAlpha = 0.5 * (i / this.history.length);
                    ctx.lineTo(this.history[i].x, this.history[i].y);
                }
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 2;
                ctx.stroke();

                // 로켓 머리 (현재 위치) 그리기
                ctx.globalAlpha = 1;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();

                ctx.restore();
            }
        }

        // ------------------------------------
        // 이벤트 핸들러 및 애니메이션 루프
        // ------------------------------------

        // 클릭 이벤트 핸들러: 새 로켓 발사
        function launchFirework(e) {
            // 안내 메시지 숨기기
            document.getElementById('message').classList.add('hidden');

            const targetX = e.clientX;
            const targetY = e.clientY;

            // 캔버스 중앙 하단에서 시작
            const startX = canvas.width / 2;
            const startY = canvas.height;

            // 로켓을 캔버스 중앙 하단에서 클릭한 위치로 발사
            const rocket = new Rocket(targetX, targetY, startX, startY);
            rockets.push(rocket);
        }

        // 메인 애니메이션 루프
        function animate() {
            requestAnimationFrame(animate);

            // 잔상 효과: 이전 프레임 위에 반투명한 검정 사각형을 덮어 그립니다.
            ctx.fillStyle = 'rgba(0, 0, 0, 0.07)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // 1. 로켓 업데이트 및 그리기
            // filter를 사용하여 update()가 true를 반환하는 (아직 폭발하지 않은) 로켓만 남깁니다.
            rockets = rockets.filter(rocket => {
                const isActive = rocket.update();
                if (isActive) {
                    rocket.draw();
                }
                return isActive;
            });

            // 2. 입자 업데이트 및 그리기
            // filter를 사용하여 update()가 true를 반환하는 (아직 소멸하지 않은) 입자만 남깁니다.
            particles = particles.filter(particle => {
                const isActive = particle.update();
                if (isActive) {
                    particle.draw();
                }
                return isActive;
            });
        }

        // 초기화 함수
        function init() {
            canvas = document.getElementById('fireworksCanvas');
            ctx = canvas.getContext('2d');

            // 캔버스 크기 초기 설정 및 창 크기 변경 시 재설정 이벤트 리스너 추가
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // 클릭 이벤트 리스너 추가
            canvas.addEventListener('click', launchFirework);

            // 애니메이션 시작
            animate();

            console.log("폭죽 시뮬레이션이 시작되었습니다. 캔버스를 클릭하세요!");
        }

        // 창 로드 후 초기화
        window.onload = init;
    </script>
</body>
</html>
